========== RULES OF THE GAME

- The rules of the game are the rules of Onitama // TODO Add edition and date
- The two players are named A and B, and A plays first

========== RULES OF THE CONTEST

- The purpose is to program the best-playing AI or Onitama
- The goal is to beat the opponent AI on two games:
  - One by being player A
  - One by being player B
- Each AI is free to work as wanted, but has to respect a few rules
  - It has to play in less than 10 seconds every time (automatically checked)
  - It has to play only valid moves (automatically checked)
  - It must not modify any data of the game by itself, only return its response
  - ANY breach to these rules results in an immediate defeat of the player

========== IMPLEMENTATION

- Each AI extends the Player abstract class
  - The Play method takes a copy of the current game board and returns the AI's move for this turn as a TurnResponse
    object
  - The constructor must take a Team enum as a parameter
- The Board object represents the game board and the cards:
  - It has four public attributes:
    - table, a 2D table of Piece objects, being the actual game board
    - handA and handB, two Pair<Card, Card> objects symbolizing the two cards of each player
    - freeCard, the free card
  - It has two constructors:
    - The first one takes no argument and constructs a standard new game Board, with all the cards randomized
    - The second one takes table, handA, handB and freeCard as parameters (WARNING: no copy is made inside the
      constructor)
  - It has four methods:
    - HasWon returns a Team value showing the player who has ALREADY won (or Team.none if none, of course)
    - ApplyTurn applies the move described by a TurnResponse to the Board and return true, or does nothing except
      returning false if the move is invalid
    - DeepCopy deep-copies the Board and returns the copy
    - toString returns a prettified string to display the Board
- In the table of the Board, player A is at the bottom (y = 4) and player B is on top (y = 0)
  - WARNING the AIs therefore have to consider looking at the table upside-down, if they are on team B
- The Card object represents a card and all the moves it allows
  - GetName returns the name of the Card
  - GetMoves return an int 5x5 table representing the moves allowed by the Card
    - 2 represents the position of the moving piece (the only '2' cell is located in (2, 2))
    - 1 represents a cell to which the piece can move using this Card
    - 0 represents a cell to which the piece cannot move using this Card
- The table of the Card object is oriented as if the moving piece is player A's
  - WARNING the AIs therefore have to consider rotating the Card's table, if they are on team B